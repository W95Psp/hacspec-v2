---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: fstar
  info:
    name: generics
    manifest: generics/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = '''
Compiling generics v0.1.0 (WORKSPACE_ROOT/generics)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'''

[stdout]
diagnostics = []

[stdout.files]
"Generics.Defaults_generics.fst" = '''
module Generics.Defaults_generics
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

type t_Defaults (v_T: Type0) (v_N: usize) = | Defaults : t_Array v_T v_N -> t_Defaults v_T v_N

let f (_: t_Defaults Prims.unit (sz 2)) : Prims.unit = ()
'''
"Generics.fst" = '''
module Generics
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

let impl__Bar__inherent_impl_generics (#v_T: Type0) (v_N: usize) (x: t_Array v_T v_N) : Prims.unit =
  ()

class t_Foo (#v_Self: Type0) = {
  f_const_add_pre:v_N: usize -> v_Self -> bool;
  f_const_add_post:v_N: usize -> v_Self -> usize -> bool;
  f_const_add:v_N: usize -> x0: v_Self
    -> Prims.Pure usize (f_const_add_pre v_N x0) (fun result -> f_const_add_post v_N x0 result)
}

[@@ FStar.Tactics.Typeclasses.tcinstance]
let impl_Foo_for_usize: t_Foo #usize =
  {
    f_const_add_pre = (fun (v_N: usize) (self: usize) -> true);
    f_const_add_post = (fun (v_N: usize) (self: usize) (out: usize) -> true);
    f_const_add = fun (v_N: usize) (self: usize) -> self +! v_N
  }

let dup
      (#v_T: Type0)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: Core.Clone.t_Clone v_T)
      (x: v_T)
    : (v_T & v_T) = Core.Clone.f_clone #v_T x, Core.Clone.f_clone #v_T x <: (v_T & v_T)

let f (v_N x: usize) : usize = (v_N +! v_N <: usize) +! x

let call_f (_: Prims.unit) : usize = (f (sz 10) (sz 3) <: usize) +! sz 3

let g
      (v_N: usize)
      (#v_T: Type0)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: Core.Convert.t_Into v_T (t_Array usize v_N))
      (arr: v_T)
    : usize =
  (Core.Option.impl__unwrap_or #usize
      (Core.Iter.Traits.Iterator.f_max #(Core.Array.Iter.t_IntoIter usize v_N)
          (Core.Iter.Traits.Collect.f_into_iter #(t_Array usize v_N)
              (Core.Convert.f_into #v_T #(t_Array usize v_N) arr <: t_Array usize v_N)
            <:
            Core.Array.Iter.t_IntoIter usize v_N)
        <:
        Core.Option.t_Option usize)
      v_N
    <:
    usize) +!
  v_N

let call_g (_: Prims.unit) : usize =
  (g (sz 3)
      #(t_Array usize (sz 3))
      (let list = [sz 42; sz 3; sz 49] in
        FStar.Pervasives.assert_norm (Prims.eq2 (List.Tot.length list) 3);
        Rust_primitives.Hax.array_of_list 3 list)
    <:
    usize) +!
  sz 3

let foo (v_LEN: usize) (arr: t_Array usize v_LEN) : usize =
  let acc:usize = v_LEN +! sz 9 in
  let acc:usize =
    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
            usize)
          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_LEN }
            <:
            Core.Ops.Range.t_Range usize)
        <:
        Core.Ops.Range.t_Range usize)
      acc
      (fun acc i ->
          let acc:usize = acc in
          let i:usize = i in
          acc +! (arr.[ i ] <: usize) <: usize)
  in
  acc

let repeat
      (v_LEN: usize)
      (#v_T: Type0)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: Core.Marker.t_Copy v_T)
      (x: v_T)
    : t_Array v_T v_LEN = Rust_primitives.Hax.repeat x v_LEN

type t_Bar = | Bar : t_Bar
'''
